```
<접근법>
1. input에서 받아오는 array의 [i][j]는 도시 i에서 j로 가기 위한 비용을 나타낸다. -> 호석이 두마리 치킨에서 만드는 array랑 비슷
2. 테트로도미노 문제처럼 백트래킹으로 풀기
3. Q. 제자리 돌아오는 문제로 플로이드 와샬 쓸 수 있는지??
```
```python
<틀린 풀이 : 왜틀린지모르겠음 ㅠㅠㅠㅠ>
import sys
input = sys.stdin.readline

n = int(input())
arr = []

for _ in range(n):
    arr.append(list(map(int, input().split())))

dis = sys.maxsize
def back(start, tmp, path, cnt, ori):
    global dis
    if tmp > dis:
        return 
    
    if cnt == n-1:
        dis = min(dis, tmp+arr[start][ori])
        return
    
    for j in range(n):
        if j != start and str(j) not in path:
            back(j, tmp + arr[start][j], path+','+str(j), cnt+1, ori)

for s in range(n):
    back(s, 0, str(s), 0, s)
        
print(dis)

<정답인 풀이: visited로 모두 방문했는지 관리>
import sys
input = sys.stdin.readline

n = int(input())
arr = []
visited = [0]*n

for _ in range(n):
    arr.append(list(map(int, input().split())))

dis = 999999
def back(start, tmp, cnt, ori):
    global dis
    if cnt == n-1:
        dis = min(dis, tmp+arr[start][ori])
        return
    
    for end in range(n):
        if arr[start][end] != 0 and visited[end] == 0:
            visited[end] = 1
            back(end, tmp + arr[start][end], cnt+1, ori)
            visited[end] = 0
            
for s in range(n):
    visited[s] = 1
    back(s, 0, 0, s)
    visited[s] = 0
print(dis)
```
